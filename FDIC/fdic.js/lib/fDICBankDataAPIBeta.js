/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/* jshint latedef:false */
/* jshint forin:false */
/* jshint noempty:false */

'use strict';

const msRest = require('ms-rest');
const ServiceClient = msRest.ServiceClient;
const WebResource = msRest.WebResource;

const models = require('./models');


/**
 * @summary Get Financial Institutions
 *
 * Returns a list of financial institutions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filters] The filter for the bank search.
 * Examples:
 * * Filter by State name
 * `STNAME:"West Virginia"`
 * * Filter for any one of multiple State names
 * `STNAME:("West Virginia","Delaware")`
 * * Filter by last updated within an inclusive date range
 * `DATEUPDT:["2010-01-01" TO "2010-12-31"]`
 * * Filter for deposits over 50,000,000 (50000 thousands of dollars)
 * `DEP:[50000 TO *]`
 *
 *
 * @param {string} [options.search] Flexible text search against institution
 * records - currently only supporting name search.
 * Search supports text search and fuzzy matching, as opposed to filters that
 * are exact matches.
 * Examples:
 * * Search by name
 * `NAME: Island`
 * * Search by name (fuzzy match)
 * `NAME: Iland`
 *
 *
 * @param {string} [options.fields] Comma delimited list of fields to search.
 *
 * @param {string} [options.sortBy] Field name by which to sort returned data
 *
 * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
 * descending (DESC)
 *
 * @param {number} [options.limit] The number of records to return. Default is
 * 10 and maximum is 10,000.
 *
 * @param {number} [options.offset] The offset of page to return.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link
 *                      Pathsen61rzinstitutionsgetresponses200contentapplicationJsonschema}
 *                      for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _searchInstitutions(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filters = (options && options.filters !== undefined) ? options.filters : undefined;
  let search = (options && options.search !== undefined) ? options.search : undefined;
  let fields = (options && options.fields !== undefined) ? options.fields : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : 'NAME';
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : 'ASC';
  let limit = (options && options.limit !== undefined) ? options.limit : 10;
  let offset = (options && options.offset !== undefined) ? options.offset : 0;
  // Validate
  try {
    if (filters !== null && filters !== undefined && typeof filters.valueOf() !== 'string') {
      throw new Error('filters must be of type string.');
    }
    if (search !== null && search !== undefined && typeof search.valueOf() !== 'string') {
      throw new Error('search must be of type string.');
    }
    if (fields !== null && fields !== undefined && typeof fields.valueOf() !== 'string') {
      throw new Error('fields must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (limit !== null && limit !== undefined && typeof limit !== 'number') {
      throw new Error('limit must be of type number.');
    }
    if (limit !== null && limit !== undefined) {
      if (limit > 10000)
      {
        throw new Error('"limit" should satisfy the constraint - "InclusiveMaximum": 10000');
      }
      if (limit < 0)
      {
        throw new Error('"limit" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (offset !== null && offset !== undefined && typeof offset !== 'number') {
      throw new Error('offset must be of type number.');
    }
    if (offset !== null && offset !== undefined) {
      if (offset < 0)
      {
        throw new Error('"offset" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (this.format !== null && this.format !== undefined && typeof this.format.valueOf() !== 'string') {
      throw new Error('this.format must be of type string.');
    }
    if (this.download !== null && this.download !== undefined && typeof this.download.valueOf() !== 'string') {
      throw new Error('this.download must be of type string.');
    }
    if (this.filename !== null && this.filename !== undefined && typeof this.filename.valueOf() !== 'string') {
      throw new Error('this.filename must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'institutions';
  let queryParameters = [];
  if (filters !== null && filters !== undefined) {
    queryParameters.push('filters=' + encodeURIComponent(filters));
  }
  if (search !== null && search !== undefined) {
    queryParameters.push('search=' + encodeURIComponent(search));
  }
  if (fields !== null && fields !== undefined) {
    queryParameters.push('fields=' + encodeURIComponent(fields));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sort_by=' + encodeURIComponent(sortBy));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sort_order=' + encodeURIComponent(sortOrder));
  }
  if (limit !== null && limit !== undefined) {
    queryParameters.push('limit=' + encodeURIComponent(limit.toString()));
  }
  if (offset !== null && offset !== undefined) {
    queryParameters.push('offset=' + encodeURIComponent(offset.toString()));
  }
  if (this.format !== null && this.format !== undefined) {
    queryParameters.push('format=' + encodeURIComponent(this.format));
  }
  if (this.download !== null && this.download !== undefined) {
    queryParameters.push('download=' + encodeURIComponent(this.download));
  }
  if (this.filename !== null && this.filename !== undefined) {
    queryParameters.push('filename=' + encodeURIComponent(this.filename));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Pathsen61rzinstitutionsgetresponses200contentapplicationJsonschema']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get Institution Locations
 *
 * Returns locations/branches of financial institutions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filters] The filter for the location search.
 *
 * @param {string} [options.fields] Comma delimited list of fields to return.
 *
 * @param {string} [options.sortBy] Field name by which to sort returned data
 *
 * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
 * descending (DESC)
 *
 * @param {number} [options.limit] The number of records to return. Default is
 * 10 and maximum is 10,000.
 *
 * @param {number} [options.offset] The offset of page to return.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link
 *                      Pathsl90g6vlocationsgetresponses200contentapplicationJsonschema}
 *                      for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _searchLocations(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filters = (options && options.filters !== undefined) ? options.filters : undefined;
  let fields = (options && options.fields !== undefined) ? options.fields : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : 'NAME';
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : 'ASC';
  let limit = (options && options.limit !== undefined) ? options.limit : 10;
  let offset = (options && options.offset !== undefined) ? options.offset : 0;
  // Validate
  try {
    if (filters !== null && filters !== undefined && typeof filters.valueOf() !== 'string') {
      throw new Error('filters must be of type string.');
    }
    if (fields !== null && fields !== undefined && typeof fields.valueOf() !== 'string') {
      throw new Error('fields must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (limit !== null && limit !== undefined && typeof limit !== 'number') {
      throw new Error('limit must be of type number.');
    }
    if (limit !== null && limit !== undefined) {
      if (limit > 10000)
      {
        throw new Error('"limit" should satisfy the constraint - "InclusiveMaximum": 10000');
      }
      if (limit < 0)
      {
        throw new Error('"limit" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (offset !== null && offset !== undefined && typeof offset !== 'number') {
      throw new Error('offset must be of type number.');
    }
    if (offset !== null && offset !== undefined) {
      if (offset < 0)
      {
        throw new Error('"offset" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (this.format !== null && this.format !== undefined && typeof this.format.valueOf() !== 'string') {
      throw new Error('this.format must be of type string.');
    }
    if (this.download !== null && this.download !== undefined && typeof this.download.valueOf() !== 'string') {
      throw new Error('this.download must be of type string.');
    }
    if (this.filename !== null && this.filename !== undefined && typeof this.filename.valueOf() !== 'string') {
      throw new Error('this.filename must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'locations';
  let queryParameters = [];
  if (filters !== null && filters !== undefined) {
    queryParameters.push('filters=' + encodeURIComponent(filters));
  }
  if (fields !== null && fields !== undefined) {
    queryParameters.push('fields=' + encodeURIComponent(fields));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sort_by=' + encodeURIComponent(sortBy));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sort_order=' + encodeURIComponent(sortOrder));
  }
  if (limit !== null && limit !== undefined) {
    queryParameters.push('limit=' + encodeURIComponent(limit.toString()));
  }
  if (offset !== null && offset !== undefined) {
    queryParameters.push('offset=' + encodeURIComponent(offset.toString()));
  }
  if (this.format !== null && this.format !== undefined) {
    queryParameters.push('format=' + encodeURIComponent(this.format));
  }
  if (this.download !== null && this.download !== undefined) {
    queryParameters.push('download=' + encodeURIComponent(this.download));
  }
  if (this.filename !== null && this.filename !== undefined) {
    queryParameters.push('filename=' + encodeURIComponent(this.filename));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Pathsl90g6vlocationsgetresponses200contentapplicationJsonschema']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get Historical Aggregate Data by Year
 *
 * Returns aggregate financial and structure data, subtotaled by year,
 * regarding finanical institutions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filters] The filter criteria that refines the
 * records included in the calculated result.
 * example: >-
 * STNAME:"Alabama" AND YEAR:2005
 * Examples:
 * * Filter by Community Banks (CB) vs. Savings Institutions (SI)
 * `CB_SI:CB`
 * * Filter by State name
 * `STNAME:"Virginia"`
 * * Filter for any one of multiple State names
 * `STNAME:("West Virginia","Delaware")`
 * * Filter data by the year range
 * `YEAR:["2015" TO "2017"]`
 *
 *
 * @param {string} [options.fields] Comma delimited list of fields with
 * aggregated annual financial data to return.
 *
 * @param {string} [options.sortBy] Field name by which to sort returned data
 *
 * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
 * descending (DESC)
 *
 * @param {number} [options.limit] The number of records to return. Default is
 * 10 and maximum is 10,000.
 *
 * @param {number} [options.offset] The offset of page to return.
 *
 * @param {string} [options.aggBy] The field(s) by which data will be
 * aggregated. Valid values are 'YEAR' or 'YEAR,STNAME'.
 *
 * @param {string} [options.aggTermFields] The field(s) for which aggregations
 * will be counted for each unique term.
 *
 * @param {string} [options.aggSumFields] The field(s) for which aggregations
 * will be summed or aggregated.
 *
 * @param {number} [options.aggLimit] The limit on how many aggregated results
 * will be displayed
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link
 *                      Paths7h3qd6summarygetresponses200contentapplicationJsonschema}
 *                      for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHistorical(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filters = (options && options.filters !== undefined) ? options.filters : undefined;
  let fields = (options && options.fields !== undefined) ? options.fields : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : 'YEAR';
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : 'ASC';
  let limit = (options && options.limit !== undefined) ? options.limit : 10;
  let offset = (options && options.offset !== undefined) ? options.offset : 0;
  let aggBy = (options && options.aggBy !== undefined) ? options.aggBy : undefined;
  let aggTermFields = (options && options.aggTermFields !== undefined) ? options.aggTermFields : undefined;
  let aggSumFields = (options && options.aggSumFields !== undefined) ? options.aggSumFields : undefined;
  let aggLimit = (options && options.aggLimit !== undefined) ? options.aggLimit : undefined;
  // Validate
  try {
    if (filters !== null && filters !== undefined && typeof filters.valueOf() !== 'string') {
      throw new Error('filters must be of type string.');
    }
    if (fields !== null && fields !== undefined && typeof fields.valueOf() !== 'string') {
      throw new Error('fields must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (limit !== null && limit !== undefined && typeof limit !== 'number') {
      throw new Error('limit must be of type number.');
    }
    if (limit !== null && limit !== undefined) {
      if (limit > 10000)
      {
        throw new Error('"limit" should satisfy the constraint - "InclusiveMaximum": 10000');
      }
      if (limit < 0)
      {
        throw new Error('"limit" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (offset !== null && offset !== undefined && typeof offset !== 'number') {
      throw new Error('offset must be of type number.');
    }
    if (offset !== null && offset !== undefined) {
      if (offset < 0)
      {
        throw new Error('"offset" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (aggBy !== null && aggBy !== undefined && typeof aggBy.valueOf() !== 'string') {
      throw new Error('aggBy must be of type string.');
    }
    if (aggTermFields !== null && aggTermFields !== undefined && typeof aggTermFields.valueOf() !== 'string') {
      throw new Error('aggTermFields must be of type string.');
    }
    if (aggSumFields !== null && aggSumFields !== undefined && typeof aggSumFields.valueOf() !== 'string') {
      throw new Error('aggSumFields must be of type string.');
    }
    if (aggLimit !== null && aggLimit !== undefined && typeof aggLimit !== 'number') {
      throw new Error('aggLimit must be of type number.');
    }
    if (aggLimit !== null && aggLimit !== undefined) {
      if (aggLimit > 10000)
      {
        throw new Error('"aggLimit" should satisfy the constraint - "InclusiveMaximum": 10000');
      }
      if (aggLimit < 0)
      {
        throw new Error('"aggLimit" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (this.format !== null && this.format !== undefined && typeof this.format.valueOf() !== 'string') {
      throw new Error('this.format must be of type string.');
    }
    if (this.download !== null && this.download !== undefined && typeof this.download.valueOf() !== 'string') {
      throw new Error('this.download must be of type string.');
    }
    if (this.filename !== null && this.filename !== undefined && typeof this.filename.valueOf() !== 'string') {
      throw new Error('this.filename must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'summary';
  let queryParameters = [];
  if (filters !== null && filters !== undefined) {
    queryParameters.push('filters=' + encodeURIComponent(filters));
  }
  if (fields !== null && fields !== undefined) {
    queryParameters.push('fields=' + encodeURIComponent(fields));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sort_by=' + encodeURIComponent(sortBy));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sort_order=' + encodeURIComponent(sortOrder));
  }
  if (limit !== null && limit !== undefined) {
    queryParameters.push('limit=' + encodeURIComponent(limit.toString()));
  }
  if (offset !== null && offset !== undefined) {
    queryParameters.push('offset=' + encodeURIComponent(offset.toString()));
  }
  if (aggBy !== null && aggBy !== undefined) {
    queryParameters.push('agg_by=' + encodeURIComponent(aggBy));
  }
  if (aggTermFields !== null && aggTermFields !== undefined) {
    queryParameters.push('agg_term_fields=' + encodeURIComponent(aggTermFields));
  }
  if (aggSumFields !== null && aggSumFields !== undefined) {
    queryParameters.push('agg_sum_fields=' + encodeURIComponent(aggSumFields));
  }
  if (aggLimit !== null && aggLimit !== undefined) {
    queryParameters.push('agg_limit=' + encodeURIComponent(aggLimit.toString()));
  }
  if (this.format !== null && this.format !== undefined) {
    queryParameters.push('format=' + encodeURIComponent(this.format));
  }
  if (this.download !== null && this.download !== undefined) {
    queryParameters.push('download=' + encodeURIComponent(this.download));
  }
  if (this.filename !== null && this.filename !== undefined) {
    queryParameters.push('filename=' + encodeURIComponent(this.filename));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Paths7h3qd6summarygetresponses200contentapplicationJsonschema']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get detail on historical bank failures from 1934 to present.
 *
 * Returns details on failed financial institutions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filters] The filter criteria that refines the
 * records returned.
 * Examples:
 * * Filter by Location
 * `CITYST:"MEMPHIS, TN"`
 * * Filter by institution fail year range
 * `FAILYR:["2015" TO "2016"]`
 *
 *
 * @param {string} [options.fields] Comma delimited list of fields of failed
 * financial institutions to return.
 *
 * @param {string} [options.sortBy] Field name by which to sort returned data
 *
 * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
 * descending (DESC)
 *
 * @param {number} [options.limit] The number of records to return. Default is
 * 10 and maximum is 10,000.
 *
 * @param {number} [options.offset] The offset of page to return.
 *
 * @param {string} [options.totalFields] Fields to sum up (in a totals response
 * object). Only numeric columns are valid.
 *
 * @param {string} [options.subtotalBy] The field by which data will be
 * subtotaled (in totals response object). Only categorical values should be
 * used.
 *
 * @param {string} [options.aggBy] The field(s) by which data will be
 * aggregated. Valid values are 'FAILYR' or 'FAILYR,PSTALP'.
 *
 * @param {string} [options.aggTermFields] The field(s) for which aggregations
 * will be counted for each unique term.
 *
 * @param {string} [options.aggSumFields] The field(s) for which aggregations
 * will be summed or aggregated.
 *
 * @param {number} [options.aggLimit] The limit on how many aggregated results
 * will be displayed
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link
 *                      Paths1lzmfz0failuresgetresponses200contentapplicationJsonschema}
 *                      for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getFailures(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filters = (options && options.filters !== undefined) ? options.filters : undefined;
  let fields = (options && options.fields !== undefined) ? options.fields : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : 'FAILDATE';
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : 'ASC';
  let limit = (options && options.limit !== undefined) ? options.limit : 100;
  let offset = (options && options.offset !== undefined) ? options.offset : 0;
  let totalFields = (options && options.totalFields !== undefined) ? options.totalFields : undefined;
  let subtotalBy = (options && options.subtotalBy !== undefined) ? options.subtotalBy : undefined;
  let aggBy = (options && options.aggBy !== undefined) ? options.aggBy : undefined;
  let aggTermFields = (options && options.aggTermFields !== undefined) ? options.aggTermFields : undefined;
  let aggSumFields = (options && options.aggSumFields !== undefined) ? options.aggSumFields : undefined;
  let aggLimit = (options && options.aggLimit !== undefined) ? options.aggLimit : 10;
  // Validate
  try {
    if (filters !== null && filters !== undefined && typeof filters.valueOf() !== 'string') {
      throw new Error('filters must be of type string.');
    }
    if (fields !== null && fields !== undefined && typeof fields.valueOf() !== 'string') {
      throw new Error('fields must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (limit !== null && limit !== undefined && typeof limit !== 'number') {
      throw new Error('limit must be of type number.');
    }
    if (limit !== null && limit !== undefined) {
      if (limit > 10000)
      {
        throw new Error('"limit" should satisfy the constraint - "InclusiveMaximum": 10000');
      }
      if (limit < 0)
      {
        throw new Error('"limit" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (offset !== null && offset !== undefined && typeof offset !== 'number') {
      throw new Error('offset must be of type number.');
    }
    if (offset !== null && offset !== undefined) {
      if (offset < 0)
      {
        throw new Error('"offset" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (totalFields !== null && totalFields !== undefined && typeof totalFields.valueOf() !== 'string') {
      throw new Error('totalFields must be of type string.');
    }
    if (subtotalBy !== null && subtotalBy !== undefined && typeof subtotalBy.valueOf() !== 'string') {
      throw new Error('subtotalBy must be of type string.');
    }
    if (aggBy !== null && aggBy !== undefined && typeof aggBy.valueOf() !== 'string') {
      throw new Error('aggBy must be of type string.');
    }
    if (aggTermFields !== null && aggTermFields !== undefined && typeof aggTermFields.valueOf() !== 'string') {
      throw new Error('aggTermFields must be of type string.');
    }
    if (aggSumFields !== null && aggSumFields !== undefined && typeof aggSumFields.valueOf() !== 'string') {
      throw new Error('aggSumFields must be of type string.');
    }
    if (aggLimit !== null && aggLimit !== undefined && typeof aggLimit !== 'number') {
      throw new Error('aggLimit must be of type number.');
    }
    if (aggLimit !== null && aggLimit !== undefined) {
      if (aggLimit > 10000)
      {
        throw new Error('"aggLimit" should satisfy the constraint - "InclusiveMaximum": 10000');
      }
      if (aggLimit < 0)
      {
        throw new Error('"aggLimit" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (this.format !== null && this.format !== undefined && typeof this.format.valueOf() !== 'string') {
      throw new Error('this.format must be of type string.');
    }
    if (this.download !== null && this.download !== undefined && typeof this.download.valueOf() !== 'string') {
      throw new Error('this.download must be of type string.');
    }
    if (this.filename !== null && this.filename !== undefined && typeof this.filename.valueOf() !== 'string') {
      throw new Error('this.filename must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'failures';
  let queryParameters = [];
  if (filters !== null && filters !== undefined) {
    queryParameters.push('filters=' + encodeURIComponent(filters));
  }
  if (fields !== null && fields !== undefined) {
    queryParameters.push('fields=' + encodeURIComponent(fields));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sort_by=' + encodeURIComponent(sortBy));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sort_order=' + encodeURIComponent(sortOrder));
  }
  if (limit !== null && limit !== undefined) {
    queryParameters.push('limit=' + encodeURIComponent(limit.toString()));
  }
  if (offset !== null && offset !== undefined) {
    queryParameters.push('offset=' + encodeURIComponent(offset.toString()));
  }
  if (totalFields !== null && totalFields !== undefined) {
    queryParameters.push('total_fields=' + encodeURIComponent(totalFields));
  }
  if (subtotalBy !== null && subtotalBy !== undefined) {
    queryParameters.push('subtotal_by=' + encodeURIComponent(subtotalBy));
  }
  if (aggBy !== null && aggBy !== undefined) {
    queryParameters.push('agg_by=' + encodeURIComponent(aggBy));
  }
  if (aggTermFields !== null && aggTermFields !== undefined) {
    queryParameters.push('agg_term_fields=' + encodeURIComponent(aggTermFields));
  }
  if (aggSumFields !== null && aggSumFields !== undefined) {
    queryParameters.push('agg_sum_fields=' + encodeURIComponent(aggSumFields));
  }
  if (aggLimit !== null && aggLimit !== undefined) {
    queryParameters.push('agg_limit=' + encodeURIComponent(aggLimit.toString()));
  }
  if (this.format !== null && this.format !== undefined) {
    queryParameters.push('format=' + encodeURIComponent(this.format));
  }
  if (this.download !== null && this.download !== undefined) {
    queryParameters.push('download=' + encodeURIComponent(this.download));
  }
  if (this.filename !== null && this.filename !== undefined) {
    queryParameters.push('filename=' + encodeURIComponent(this.filename));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Paths1lzmfz0failuresgetresponses200contentapplicationJsonschema']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a FDICBankDataAPIBeta. */
class FDICBankDataAPIBeta extends ServiceClient {
  /**
   * Create a FDICBankDataAPIBeta.
   * @param {string} [baseUri] - The base URI of the service.
   * @param {object} [options] - The parameter options
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   * @param {enum} [options.format] - The format of the data to return. Possible values include: 'json', 'csv'
   * @param {enum} [options.download] - Whether the data should be downloaded as a file. Possible values include: 'false', 'true'
   * @param {string} [options.filename] - The filename to use when downloading data.
   */
  constructor(baseUri, options) {

    if (!options) options = {};

    super(null, options);

    this.baseUri = baseUri;
    if (!this.baseUri) {
      this.baseUri = 'https://banks.data.fdic.gov/api';
    }

    let packageInfo = this.getPackageJsonInfo(__dirname);
    this.addUserAgentInfo(`${packageInfo.name}/${packageInfo.version}`);
    if(options.format !== null && options.format !== undefined) {
      this.format = options.format;
    }
    if(options.download !== null && options.download !== undefined) {
      this.download = options.download;
    }
    if(options.filename !== null && options.filename !== undefined) {
      this.filename = options.filename;
    }
    this.models = models;
    this._searchInstitutions = _searchInstitutions;
    this._searchLocations = _searchLocations;
    this._getHistorical = _getHistorical;
    this._getFailures = _getFailures;
    msRest.addSerializationMixin(this);
  }

  /**
   * @summary Get Financial Institutions
   *
   * Returns a list of financial institutions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filters] The filter for the bank search.
   * Examples:
   * * Filter by State name
   * `STNAME:"West Virginia"`
   * * Filter for any one of multiple State names
   * `STNAME:("West Virginia","Delaware")`
   * * Filter by last updated within an inclusive date range
   * `DATEUPDT:["2010-01-01" TO "2010-12-31"]`
   * * Filter for deposits over 50,000,000 (50000 thousands of dollars)
   * `DEP:[50000 TO *]`
   *
   *
   * @param {string} [options.search] Flexible text search against institution
   * records - currently only supporting name search.
   * Search supports text search and fuzzy matching, as opposed to filters that
   * are exact matches.
   * Examples:
   * * Search by name
   * `NAME: Island`
   * * Search by name (fuzzy match)
   * `NAME: Iland`
   *
   *
   * @param {string} [options.fields] Comma delimited list of fields to search.
   *
   * @param {string} [options.sortBy] Field name by which to sort returned data
   *
   * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
   * descending (DESC)
   *
   * @param {number} [options.limit] The number of records to return. Default is
   * 10 and maximum is 10,000.
   *
   * @param {number} [options.offset] The offset of page to return.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Pathsen61rzinstitutionsgetresponses200contentapplicationJsonschema>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  searchInstitutionsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._searchInstitutions(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get Financial Institutions
   *
   * Returns a list of financial institutions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filters] The filter for the bank search.
   * Examples:
   * * Filter by State name
   * `STNAME:"West Virginia"`
   * * Filter for any one of multiple State names
   * `STNAME:("West Virginia","Delaware")`
   * * Filter by last updated within an inclusive date range
   * `DATEUPDT:["2010-01-01" TO "2010-12-31"]`
   * * Filter for deposits over 50,000,000 (50000 thousands of dollars)
   * `DEP:[50000 TO *]`
   *
   *
   * @param {string} [options.search] Flexible text search against institution
   * records - currently only supporting name search.
   * Search supports text search and fuzzy matching, as opposed to filters that
   * are exact matches.
   * Examples:
   * * Search by name
   * `NAME: Island`
   * * Search by name (fuzzy match)
   * `NAME: Iland`
   *
   *
   * @param {string} [options.fields] Comma delimited list of fields to search.
   *
   * @param {string} [options.sortBy] Field name by which to sort returned data
   *
   * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
   * descending (DESC)
   *
   * @param {number} [options.limit] The number of records to return. Default is
   * 10 and maximum is 10,000.
   *
   * @param {number} [options.offset] The offset of page to return.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Pathsen61rzinstitutionsgetresponses200contentapplicationJsonschema} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link
   *                      Pathsen61rzinstitutionsgetresponses200contentapplicationJsonschema}
   *                      for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  searchInstitutions(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._searchInstitutions(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._searchInstitutions(options, optionalCallback);
    }
  }

  /**
   * @summary Get Institution Locations
   *
   * Returns locations/branches of financial institutions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filters] The filter for the location search.
   *
   * @param {string} [options.fields] Comma delimited list of fields to return.
   *
   * @param {string} [options.sortBy] Field name by which to sort returned data
   *
   * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
   * descending (DESC)
   *
   * @param {number} [options.limit] The number of records to return. Default is
   * 10 and maximum is 10,000.
   *
   * @param {number} [options.offset] The offset of page to return.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Pathsl90g6vlocationsgetresponses200contentapplicationJsonschema>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  searchLocationsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._searchLocations(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get Institution Locations
   *
   * Returns locations/branches of financial institutions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filters] The filter for the location search.
   *
   * @param {string} [options.fields] Comma delimited list of fields to return.
   *
   * @param {string} [options.sortBy] Field name by which to sort returned data
   *
   * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
   * descending (DESC)
   *
   * @param {number} [options.limit] The number of records to return. Default is
   * 10 and maximum is 10,000.
   *
   * @param {number} [options.offset] The offset of page to return.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Pathsl90g6vlocationsgetresponses200contentapplicationJsonschema} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link
   *                      Pathsl90g6vlocationsgetresponses200contentapplicationJsonschema}
   *                      for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  searchLocations(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._searchLocations(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._searchLocations(options, optionalCallback);
    }
  }

  /**
   * @summary Get Historical Aggregate Data by Year
   *
   * Returns aggregate financial and structure data, subtotaled by year,
   * regarding finanical institutions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filters] The filter criteria that refines the
   * records included in the calculated result.
   * example: >-
   * STNAME:"Alabama" AND YEAR:2005
   * Examples:
   * * Filter by Community Banks (CB) vs. Savings Institutions (SI)
   * `CB_SI:CB`
   * * Filter by State name
   * `STNAME:"Virginia"`
   * * Filter for any one of multiple State names
   * `STNAME:("West Virginia","Delaware")`
   * * Filter data by the year range
   * `YEAR:["2015" TO "2017"]`
   *
   *
   * @param {string} [options.fields] Comma delimited list of fields with
   * aggregated annual financial data to return.
   *
   * @param {string} [options.sortBy] Field name by which to sort returned data
   *
   * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
   * descending (DESC)
   *
   * @param {number} [options.limit] The number of records to return. Default is
   * 10 and maximum is 10,000.
   *
   * @param {number} [options.offset] The offset of page to return.
   *
   * @param {string} [options.aggBy] The field(s) by which data will be
   * aggregated. Valid values are 'YEAR' or 'YEAR,STNAME'.
   *
   * @param {string} [options.aggTermFields] The field(s) for which aggregations
   * will be counted for each unique term.
   *
   * @param {string} [options.aggSumFields] The field(s) for which aggregations
   * will be summed or aggregated.
   *
   * @param {number} [options.aggLimit] The limit on how many aggregated results
   * will be displayed
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Paths7h3qd6summarygetresponses200contentapplicationJsonschema>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHistoricalWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHistorical(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get Historical Aggregate Data by Year
   *
   * Returns aggregate financial and structure data, subtotaled by year,
   * regarding finanical institutions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filters] The filter criteria that refines the
   * records included in the calculated result.
   * example: >-
   * STNAME:"Alabama" AND YEAR:2005
   * Examples:
   * * Filter by Community Banks (CB) vs. Savings Institutions (SI)
   * `CB_SI:CB`
   * * Filter by State name
   * `STNAME:"Virginia"`
   * * Filter for any one of multiple State names
   * `STNAME:("West Virginia","Delaware")`
   * * Filter data by the year range
   * `YEAR:["2015" TO "2017"]`
   *
   *
   * @param {string} [options.fields] Comma delimited list of fields with
   * aggregated annual financial data to return.
   *
   * @param {string} [options.sortBy] Field name by which to sort returned data
   *
   * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
   * descending (DESC)
   *
   * @param {number} [options.limit] The number of records to return. Default is
   * 10 and maximum is 10,000.
   *
   * @param {number} [options.offset] The offset of page to return.
   *
   * @param {string} [options.aggBy] The field(s) by which data will be
   * aggregated. Valid values are 'YEAR' or 'YEAR,STNAME'.
   *
   * @param {string} [options.aggTermFields] The field(s) for which aggregations
   * will be counted for each unique term.
   *
   * @param {string} [options.aggSumFields] The field(s) for which aggregations
   * will be summed or aggregated.
   *
   * @param {number} [options.aggLimit] The limit on how many aggregated results
   * will be displayed
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Paths7h3qd6summarygetresponses200contentapplicationJsonschema} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link
   *                      Paths7h3qd6summarygetresponses200contentapplicationJsonschema}
   *                      for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHistorical(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHistorical(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHistorical(options, optionalCallback);
    }
  }

  /**
   * @summary Get detail on historical bank failures from 1934 to present.
   *
   * Returns details on failed financial institutions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filters] The filter criteria that refines the
   * records returned.
   * Examples:
   * * Filter by Location
   * `CITYST:"MEMPHIS, TN"`
   * * Filter by institution fail year range
   * `FAILYR:["2015" TO "2016"]`
   *
   *
   * @param {string} [options.fields] Comma delimited list of fields of failed
   * financial institutions to return.
   *
   * @param {string} [options.sortBy] Field name by which to sort returned data
   *
   * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
   * descending (DESC)
   *
   * @param {number} [options.limit] The number of records to return. Default is
   * 10 and maximum is 10,000.
   *
   * @param {number} [options.offset] The offset of page to return.
   *
   * @param {string} [options.totalFields] Fields to sum up (in a totals response
   * object). Only numeric columns are valid.
   *
   * @param {string} [options.subtotalBy] The field by which data will be
   * subtotaled (in totals response object). Only categorical values should be
   * used.
   *
   * @param {string} [options.aggBy] The field(s) by which data will be
   * aggregated. Valid values are 'FAILYR' or 'FAILYR,PSTALP'.
   *
   * @param {string} [options.aggTermFields] The field(s) for which aggregations
   * will be counted for each unique term.
   *
   * @param {string} [options.aggSumFields] The field(s) for which aggregations
   * will be summed or aggregated.
   *
   * @param {number} [options.aggLimit] The limit on how many aggregated results
   * will be displayed
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Paths1lzmfz0failuresgetresponses200contentapplicationJsonschema>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getFailuresWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getFailures(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get detail on historical bank failures from 1934 to present.
   *
   * Returns details on failed financial institutions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filters] The filter criteria that refines the
   * records returned.
   * Examples:
   * * Filter by Location
   * `CITYST:"MEMPHIS, TN"`
   * * Filter by institution fail year range
   * `FAILYR:["2015" TO "2016"]`
   *
   *
   * @param {string} [options.fields] Comma delimited list of fields of failed
   * financial institutions to return.
   *
   * @param {string} [options.sortBy] Field name by which to sort returned data
   *
   * @param {string} [options.sortOrder] Indicator if ascending (ASC) or
   * descending (DESC)
   *
   * @param {number} [options.limit] The number of records to return. Default is
   * 10 and maximum is 10,000.
   *
   * @param {number} [options.offset] The offset of page to return.
   *
   * @param {string} [options.totalFields] Fields to sum up (in a totals response
   * object). Only numeric columns are valid.
   *
   * @param {string} [options.subtotalBy] The field by which data will be
   * subtotaled (in totals response object). Only categorical values should be
   * used.
   *
   * @param {string} [options.aggBy] The field(s) by which data will be
   * aggregated. Valid values are 'FAILYR' or 'FAILYR,PSTALP'.
   *
   * @param {string} [options.aggTermFields] The field(s) for which aggregations
   * will be counted for each unique term.
   *
   * @param {string} [options.aggSumFields] The field(s) for which aggregations
   * will be summed or aggregated.
   *
   * @param {number} [options.aggLimit] The limit on how many aggregated results
   * will be displayed
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Paths1lzmfz0failuresgetresponses200contentapplicationJsonschema} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link
   *                      Paths1lzmfz0failuresgetresponses200contentapplicationJsonschema}
   *                      for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getFailures(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getFailures(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getFailures(options, optionalCallback);
    }
  }

}

module.exports = FDICBankDataAPIBeta;
module.exports['default'] = FDICBankDataAPIBeta;
module.exports.FDICBankDataAPIBeta = FDICBankDataAPIBeta;
module.exports.FDICBankDataAPIBetaModels = models;
